# Notes

@henrikgr I found the fix and just sent you a Pull Request on GitHub.  The root of the problem is that Gatsby can't handle a mix of local and remote files with the same graphQL variable (imageURL in your case).  Local files get moved around and get mangled filenames (e.g.- ./myimage.png becomes something like public/static/myimage-6f11241f0d717b0c4e163986ba76fe0b.png on the website build), and their query types are File.  And remote file URLs are simply strings, with a query type of String.  Since GraphQL has a fixed type definition for each field, you can't keep remote URLs and local file File definitions in the same imageURL field.

Keeping everything in string form would work, except for the name mangling.  You can avoid that by putting any local images in a static folder off the root of your project.  Anything in there gets copied as is (no name mangling) into the /public/static folder when you build.  So you can reference ./myimage.png safely if you put it in that folder.  So a quick fix for your problem is to move the `javascript-illustration.png` file into a new \static folder off the project root.  That way, all the URLs can be kept in string form and the local file URL works because it's name is unmangled.  I tried this and it works.  But as they discuss in the Gatsby documentation [Using the Static folder](https://www.gatsbyjs.org/docs/static-folder/), this is not recommended because removing the mangling (hashes added to the file names) will not trigger browser cache updates if your files change, and the compiler can't catch missing file errors (instead the users will see 404 errors).  So the better way to do this is to work with the Gatsy filename mangling (hashes).

If you aren't familiar with the hash mechanism, here's a quick overview:  The Gatsby build process detects any local files you need, and then modifies their names by adding hashes and reorganizing where they go in the folders of the built site.  It also processes your code to make sure it knows about the new name and location of the file.  For example, if you look at the HTML code that results from processing your markdown files, you will see that the file links in there have changed from the original markdown source.  And every time you compile with any changes, the hash will change so that the browsers see the new file rather than pulling an old version out of the cache.  Without the added hash on the names, the browser wouldn't know there was a difference and you'd have to keep telling users (and remind yourself) to flush the browser cache.

The fix I sent you (via PR) works by keeping all the images locally by downloading all the remote ones to local copies.  I did it manually, but you could also write a script to do that as part of your build process so you always have the latest if the remote changes.  Then the Gatsby type inference code sees that all the imageURL values in the various markdown frontmatter are all local files, and it makes the imageURL a File type.  This is more than a simple URL string and has a bunch of data, such as `size`, `absolutePath`, `relativePath`, `modifiedTime`, `internal` and so forth.  But you can't use the Path data since it is for the original location, not where it ends up on your built website.  For the runtime path you want `publicURL` which gives you the website path with the mangled file name.  So you will see in your code that I changed the imageURL references to imageURL.publicURL to get access to this.

BTW, you can either query the `imageURL` and then use `imageURL.publicURL` to access the file URL, like I did, or if you don't need any of the other data about the File (like size), then you can put `imageURL { publicURL }` in your query and then use `publicURL` directly in your JavaScript code.  You can see an example of that at the bottom of this [Gatsby documentation](https://www.gatsbyjs.org/docs/importing-assets-into-files/) page.

If you still would rather have a mix of local and remote files, then another way to do this and get around the fixed type of graphQL fields is to break the local and remote into two fields, such as `imageURL` for the remote files and `imageFile` for the local files.  The `imageURL` would have String type and `imageFile` would be a File type.  Then you could modify your page generation code to see which was used, and load the appropriate image.
